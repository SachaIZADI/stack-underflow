[{"title": "How to print the full NumPy array, without truncation?", "question_body": "<p>When I print a numpy array, I get a truncated representation, but I want the full array. </p>\n\n<p>Is there any way to do this?</p>\n\n<p><strong>Examples:</strong></p>\n\n<pre><code>&gt;&gt;&gt; numpy.arange(10000)\narray([   0,    1,    2, ..., 9997, 9998, 9999])\n\n&gt;&gt;&gt; numpy.arange(10000).reshape(250,40)\narray([[   0,    1,    2, ...,   37,   38,   39],\n       [  40,   41,   42, ...,   77,   78,   79],\n       [  80,   81,   82, ...,  117,  118,  119],\n       ..., \n       [9880, 9881, 9882, ..., 9917, 9918, 9919],\n       [9920, 9921, 9922, ..., 9957, 9958, 9959],\n       [9960, 9961, 9962, ..., 9997, 9998, 9999]])\n</code></pre>\n", "link": "https://stackoverflow.com/questions/1987694/how-to-print-the-full-numpy-array-without-truncation", "question_id": 1987694, "accepted_answer_id": 1988024, "answer_body": "<p>Use <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html\" rel=\"noreferrer\"><code>numpy.set_printoptions</code></a>:</p>\n\n<pre><code>import sys\nimport numpy\nnumpy.set_printoptions(threshold=sys.maxsize)\n</code></pre>\n"}, {"title": "Dump a NumPy array into a csv file", "question_body": "<p>Is there a way to dump a NumPy array into a CSV file? I have a 2D NumPy array and need to dump it in human-readable format.</p>\n", "link": "https://stackoverflow.com/questions/6081008/dump-a-numpy-array-into-a-csv-file", "question_id": 6081008, "accepted_answer_id": 6081043, "answer_body": "<p><a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html\" rel=\"noreferrer\"><code>numpy.savetxt</code></a> saves an array to a text file.</p>\n\n<pre><code>import numpy\na = numpy.asarray([ [1,2,3], [4,5,6], [7,8,9] ])\nnumpy.savetxt(\"foo.csv\", a, delimiter=\",\")\n</code></pre>\n"}, {"title": "How can the Euclidean distance be calculated with NumPy?", "question_body": "<p>I have two points in 3D:</p>\n\n<pre><code>(xa, ya, za)\n(xb, yb, zb)\n</code></pre>\n\n<p>And I want to calculate the distance:</p>\n\n<pre><code>dist = sqrt((xa-xb)^2 + (ya-yb)^2 + (za-zb)^2)\n</code></pre>\n\n<p>What's the best way to do this with NumPy, or with Python in general? I have:</p>\n\n<pre><code>a = numpy.array((xa ,ya, za))\nb = numpy.array((xb, yb, zb))\n</code></pre>\n", "link": "https://stackoverflow.com/questions/1401712/how-can-the-euclidean-distance-be-calculated-with-numpy", "question_id": 1401712, "accepted_answer_id": 1401828, "answer_body": "<p>Use <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.norm.html\" rel=\"noreferrer\"><code>numpy.linalg.norm</code></a>:</p>\n\n<pre><code>dist = numpy.linalg.norm(a-b)\n</code></pre>\n\n<p>Theory Behind this: as found in <strong><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321321367\" rel=\"noreferrer\" rel=\"nofollow noreferrer\">Introduction to Data Mining</a></strong></p>\n\n<p>This works because <strong>Euclidean distance</strong> is <strong>l2 norm</strong> and the default value of <strong>ord</strong> parameter in numpy.linalg.norm is 2.</p>\n\n<p><a href=\"https://i.stack.imgur.com/iWe4J.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/iWe4J.png\" alt=\"enter image description here\"></a></p>\n"}, {"title": "What are the advantages of NumPy over regular Python lists?", "question_body": "<p>What are the advantages of <a href=\"http://en.wikipedia.org/wiki/NumPy\" rel=\"noreferrer\">NumPy</a> over regular Python lists?</p>\n\n<p>I have approximately 100 financial markets series, and I am going to create a cube array of 100x100x100 = 1 million cells. I will be regressing (3-variable) each x with each y and z, to fill the array with standard errors.</p>\n\n<p>I have heard that for \"large matrices\" I should use NumPy as opposed to Python lists, for performance and scalability reasons. Thing is, I know Python lists and they seem to work for me. </p>\n\n<p>What will the benefits be if I move to NumPy?</p>\n\n<p>What if I had 1000 series (that is, 1 billion floating point cells in the cube)? </p>\n", "link": "https://stackoverflow.com/questions/993984/what-are-the-advantages-of-numpy-over-regular-python-lists", "question_id": 993984, "accepted_answer_id": 994010, "answer_body": "<p>NumPy's arrays are more compact than Python lists -- a list of lists as you describe, in Python, would take at least 20 MB or so, while a NumPy 3D array with single-precision floats in the cells would fit in 4 MB. Access in reading and writing items is also faster with NumPy.</p>\n\n<p>Maybe you don't care that much for just a million cells, but you definitely would for a billion cells -- neither approach would fit in a 32-bit architecture, but with 64-bit builds NumPy would get away with 4 GB or so, Python alone would need at least about 12 GB (lots of pointers which double in size) -- a much costlier piece of hardware!</p>\n\n<p>The difference is mostly due to \"indirectness\" -- a Python list is an array of pointers to Python objects, at least 4 bytes per pointer plus 16 bytes for even the smallest Python object (4 for type pointer, 4 for reference count, 4 for value -- and the memory allocators rounds up to 16). A NumPy array is an array of uniform values -- single-precision numbers takes 4 bytes each, double-precision ones, 8 bytes. Less flexible, but you pay substantially for the flexibility of standard Python lists!</p>\n"}, {"title": "Is there a NumPy function to return the first index of something in an array?", "question_body": "<p>I know there is a method for a Python list to return the first index of something:</p>\n\n<pre><code>&gt;&gt;&gt; l = [1, 2, 3]\n&gt;&gt;&gt; l.index(2)\n1\n</code></pre>\n\n<p>Is there something like that for NumPy arrays?</p>\n", "link": "https://stackoverflow.com/questions/432112/is-there-a-numpy-function-to-return-the-first-index-of-something-in-an-array", "question_id": 432112, "accepted_answer_id": 432289, "answer_body": "<p>Yes, here is the answer given a NumPy array, <code>array</code>, and a value, <code>item</code>, to search for:</p>\n\n<pre><code>itemindex = numpy.where(array==item)\n</code></pre>\n\n<p>The result is a tuple with first all the row indices, then all the column indices.</p>\n\n<p>For example, if an array is two dimensions and it contained your item at two locations then</p>\n\n<pre><code>array[itemindex[0][0]][itemindex[1][0]]\n</code></pre>\n\n<p>would be equal to your item and so would</p>\n\n<pre><code>array[itemindex[0][1]][itemindex[1][1]]\n</code></pre>\n\n<p><a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html\" rel=\"noreferrer\">numpy.where</a></p>\n"}, {"title": "How do I get indices of N maximum values in a NumPy array?", "question_body": "<p>NumPy proposes a way to get the index of the maximum value of an array via <code>np.argmax</code>.</p>\n\n<p>I would like a similar thing, but returning the indexes of the <code>N</code> maximum values.</p>\n\n<p>For instance, if I have an array, <code>[1, 3, 2, 4, 5]</code>, <code>function(array, n=3)</code> would return the indices <code>[4, 3, 1]</code> which correspond to the elements <code>[5, 4, 3]</code>.</p>\n", "link": "https://stackoverflow.com/questions/6910641/how-do-i-get-indices-of-n-maximum-values-in-a-numpy-array", "question_id": 6910641, "accepted_answer_id": 6910672, "answer_body": "<p>The simplest I've been able to come up with is:</p>\n\n<pre><code>In [1]: import numpy as np\n\nIn [2]: arr = np.array([1, 3, 2, 4, 5])\n\nIn [3]: arr.argsort()[-3:][::-1]\nOut[3]: array([4, 3, 1])\n</code></pre>\n\n<p>This involves a complete sort of the array. I wonder if <code>numpy</code> provides a built-in way to do a partial sort; so far I haven't been able to find one.</p>\n\n<p>If this solution turns out to be too slow (especially for small <code>n</code>), it may be worth looking at coding something up in <a href=\"http://cython.org/\">Cython</a>.</p>\n"}, {"title": "How to access the ith column of a NumPy multidimensional array?", "question_body": "<p>Suppose I have:</p>\n\n<pre><code>test = numpy.array([[1, 2], [3, 4], [5, 6]])\n</code></pre>\n\n<p><code>test[i]</code> gets me <em>ith</em> line of the array (eg <code>[1, 2]</code>). How can I access the <em>ith</em> column? (eg <code>[1, 3, 5]</code>). Also, would this be an expensive operation?</p>\n", "link": "https://stackoverflow.com/questions/4455076/how-to-access-the-ith-column-of-a-numpy-multidimensional-array", "question_id": 4455076, "accepted_answer_id": 4455154, "answer_body": "<pre><code>&gt;&gt;&gt; test[:,0]\narray([1, 3, 5])\n</code></pre>\n\n<p>Similarly, </p>\n\n<pre><code>&gt;&gt;&gt; test[1,:]\narray([3, 4])\n</code></pre>\n\n<p>lets you access rows.  This is covered in Section 1.4 (Indexing) of the <a href=\"http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html\" rel=\"noreferrer\">NumPy reference</a>.  This is quick, at least in my experience.  It's certainly much quicker than accessing each element in a loop.</p>\n"}, {"title": "StringIO in Python3", "question_body": "<p>I am using Python 3.2.1 and I can't import the <code>StringIO</code> module. I use \n<code>io.StringIO</code> and it works, but I can't use it with <code>numpy</code>'s <code>genfromtxt</code> like this:</p>\n\n<pre><code>x=\"1 3\\n 4.5 8\"        \nnumpy.genfromtxt(io.StringIO(x))\n</code></pre>\n\n<p>I get the following error:</p>\n\n<pre><code>TypeError: Can't convert 'bytes' object to str implicitly  \n</code></pre>\n\n<p>and when I write <code>import StringIO</code> it says</p>\n\n<pre><code>ImportError: No module named 'StringIO'\n</code></pre>\n", "link": "https://stackoverflow.com/questions/11914472/stringio-in-python3", "question_id": 11914472, "accepted_answer_id": null}, {"title": "Combine two columns of text in dataframe in pandas/python", "question_body": "<p>I have a 20 x 4000 dataframe in python using pandas. Two of these columns are named Year and quarter. I'd like to create a variable called period that makes Year = 2000 and quarter= q2 into 2000q2</p>\n\n<p>Can anyone help with that?</p>\n", "link": "https://stackoverflow.com/questions/19377969/combine-two-columns-of-text-in-dataframe-in-pandas-python", "question_id": 19377969, "accepted_answer_id": null}, {"title": "Convert pandas dataframe to NumPy array", "question_body": "<p>I am interested in knowing how to convert a pandas dataframe into a NumPy array.</p>\n\n<p>dataframe:</p>\n\n<pre><code>import numpy as np\nimport pandas as pd\n\nindex = [1, 2, 3, 4, 5, 6, 7]\na = [np.nan, np.nan, np.nan, 0.1, 0.1, 0.1, 0.1]\nb = [0.2, np.nan, 0.2, 0.2, 0.2, np.nan, np.nan]\nc = [np.nan, 0.5, 0.5, np.nan, 0.5, 0.5, np.nan]\ndf = pd.DataFrame({'A': a, 'B': b, 'C': c}, index=index)\ndf = df.rename_axis('ID')\n</code></pre>\n\n<p>gives</p>\n\n<pre><code>label   A    B    C\nID                                 \n1   NaN  0.2  NaN\n2   NaN  NaN  0.5\n3   NaN  0.2  0.5\n4   0.1  0.2  NaN\n5   0.1  0.2  0.5\n6   0.1  NaN  0.5\n7   0.1  NaN  NaN\n</code></pre>\n\n<p>I would like to convert this to a NumPy array, as so:</p>\n\n<pre><code>array([[ nan,  0.2,  nan],\n       [ nan,  nan,  0.5],\n       [ nan,  0.2,  0.5],\n       [ 0.1,  0.2,  nan],\n       [ 0.1,  0.2,  0.5],\n       [ 0.1,  nan,  0.5],\n       [ 0.1,  nan,  nan]])\n</code></pre>\n\n<p>How can I do this? </p>\n\n<hr>\n\n<p>As a bonus, is it possible to preserve the dtypes, like this?</p>\n\n<pre><code>array([[ 1, nan,  0.2,  nan],\n       [ 2, nan,  nan,  0.5],\n       [ 3, nan,  0.2,  0.5],\n       [ 4, 0.1,  0.2,  nan],\n       [ 5, 0.1,  0.2,  0.5],\n       [ 6, 0.1,  nan,  0.5],\n       [ 7, 0.1,  nan,  nan]],\n     dtype=[('ID', '&lt;i4'), ('A', '&lt;f8'), ('B', '&lt;f8'), ('B', '&lt;f8')])\n</code></pre>\n\n<p>or similar?</p>\n", "link": "https://stackoverflow.com/questions/13187778/convert-pandas-dataframe-to-numpy-array", "question_id": 13187778, "accepted_answer_id": null}, {"title": "How do I read CSV data into a record array in NumPy?", "question_body": "<p>I wonder if there is a direct way to import the contents of a CSV file into a record array, much in the way that R's <code>read.table()</code>, <code>read.delim()</code>, and <code>read.csv()</code> family imports data to R's data frame?</p>\n\n<p>Or is the best way to use <a href=\"https://stackoverflow.com/questions/2859404/reading-csv-files-in-scipy-numpy-in-python\">csv.reader()</a> and then apply something like <code>numpy.core.records.fromrecords()</code>?</p>\n", "link": "https://stackoverflow.com/questions/3518778/how-do-i-read-csv-data-into-a-record-array-in-numpy", "question_id": 3518778, "accepted_answer_id": 3519314, "answer_body": "<p>You can use Numpy's <code>genfromtxt()</code> method to do so, by setting the <code>delimiter</code> kwarg to a comma.</p>\n\n<pre><code>from numpy import genfromtxt\nmy_data = genfromtxt('my_file.csv', delimiter=',')\n</code></pre>\n\n<p>More information on the function can be found at its respective <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html\" rel=\"noreferrer\">documentation</a>.</p>\n"}, {"title": "Simple Digit Recognition OCR in OpenCV-Python", "question_body": "<p>I am trying to implement a \"Digit Recognition OCR\" in OpenCV-Python (cv2). It is just for learning purposes. I would like to learn both KNearest and SVM features in OpenCV. </p>\n\n<p>I have 100 samples (i.e. images) of each digit. I would like to train with them.</p>\n\n<p>There is a sample <code>letter_recog.py</code> that comes with OpenCV sample. But I still couldn't figure out on how to use it. I don't understand what are the samples, responses etc. Also, it loads a txt file at first, which I didn't understand first.</p>\n\n<p>Later on searching a little bit, I could find a letter_recognition.data in cpp samples. I used it and made a code for cv2.KNearest in the model of letter_recog.py (just for testing):</p>\n\n<pre><code>import numpy as np\nimport cv2\n\nfn = 'letter-recognition.data'\na = np.loadtxt(fn, np.float32, delimiter=',', converters={ 0 : lambda ch : ord(ch)-ord('A') })\nsamples, responses = a[:,1:], a[:,0]\n\nmodel = cv2.KNearest()\nretval = model.train(samples,responses)\nretval, results, neigh_resp, dists = model.find_nearest(samples, k = 10)\nprint results.ravel()\n</code></pre>\n\n<p>It gave me an array of size 20000, I don't understand what it is.</p>\n\n<p><strong>Questions:</strong></p>\n\n<p>1) What is letter_recognition.data file? How to build that file from my own data set?</p>\n\n<p>2) What does <code>results.reval()</code> denote? </p>\n\n<p>3) How we can write a simple digit recognition tool using letter_recognition.data file (either KNearest or SVM)?</p>\n", "link": "https://stackoverflow.com/questions/9413216/simple-digit-recognition-ocr-in-opencv-python", "question_id": 9413216, "accepted_answer_id": 9620295, "answer_body": "<p>Well, I decided to workout myself on my question to solve above problem. What I wanted is to implement a simpl OCR using KNearest or SVM features in OpenCV. And below is what I did and how. ( it is just for learning how to use KNearest for simple OCR purposes).</p>\n\n<p><strong>1)</strong> My first question was about letter_recognition.data file that comes with OpenCV samples. I wanted to know what is inside that file.</p>\n\n<p>It contains a letter, along with 16 features of that letter.</p>\n\n<p>And <a href=\"https://stackoverflow.com/questions/1270798/how-to-create-data-fom-image-like-letter-image-recognition-dataset-from-uci\"><code>this SOF</code></a> helped me to find it. These 16 features are explained in the paper<a href=\"http://cns-classes.bu.edu/cn550/Readings/frey-slate-91.pdf\" rel=\"noreferrer\"><strong><code>Letter Recognition Using Holland-Style Adaptive Classifiers</code></strong></a>.\n( Although I didn't understand some of the features at end)</p>\n\n<p><strong>2)</strong> Since I knew, without understanding all those features, it is difficult to do that method. I tried some other papers, but all were a little difficult for a beginner.</p>\n\n<p><code>So I just decided to take all the pixel values as my features.</code> (I was not worried about accuracy or performance, I just wanted it to work, at least with the least accuracy)</p>\n\n<p>I took below image for my training data:</p>\n\n<p><img src=\"https://i.stack.imgur.com/IwQY6.png\" alt=\"enter image description here\"></p>\n\n<p>( I know the amount of training data is less. But, since all letters are of same font and size, I decided to try on this).</p>\n\n<p><strong>To prepare the data for training, I made a small code in OpenCV. It does following things:</strong></p>\n\n<ol>\n<li>It loads the image.</li>\n<li>Selects the digits ( obviously by contour finding and applying constraints on area and height of letters to avoid false detections).</li>\n<li>Draws the bounding rectangle around one letter and wait for <code>key press manually</code>. This time we <strong>press the digit key ourselves</strong> corresponding to the letter in box.</li>\n<li>Once corresponding digit key is pressed, it resizes this box to 10x10 and saves 100 pixel values in an array (here, samples) and corresponding manually entered digit in another array(here, responses).</li>\n<li>Then save both the arrays in separate txt files.</li>\n</ol>\n\n<p>At the end of manual classification of digits, all the digits in the train data( train.png) are labeled manually by ourselves, image will look like below:</p>\n\n<p><img src=\"https://i.stack.imgur.com/jyAhT.png\" alt=\"enter image description here\"></p>\n\n<p>Below is the code I used for above purpose ( of course, not so clean):</p>\n\n<pre><code>import sys\n\nimport numpy as np\nimport cv2\n\nim = cv2.imread('pitrain.png')\nim3 = im.copy()\n\ngray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray,(5,5),0)\nthresh = cv2.adaptiveThreshold(blur,255,1,1,11,2)\n\n#################      Now finding Contours         ###################\n\ncontours,hierarchy = cv2.findContours(thresh,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)\n\nsamples =  np.empty((0,100))\nresponses = []\nkeys = [i for i in range(48,58)]\n\nfor cnt in contours:\n    if cv2.contourArea(cnt)&gt;50:\n        [x,y,w,h] = cv2.boundingRect(cnt)\n\n        if  h&gt;28:\n            cv2.rectangle(im,(x,y),(x+w,y+h),(0,0,255),2)\n            roi = thresh[y:y+h,x:x+w]\n            roismall = cv2.resize(roi,(10,10))\n            cv2.imshow('norm',im)\n            key = cv2.waitKey(0)\n\n            if key == 27:  # (escape to quit)\n                sys.exit()\n            elif key in keys:\n                responses.append(int(chr(key)))\n                sample = roismall.reshape((1,100))\n                samples = np.append(samples,sample,0)\n\nresponses = np.array(responses,np.float32)\nresponses = responses.reshape((responses.size,1))\nprint \"training complete\"\n\nnp.savetxt('generalsamples.data',samples)\nnp.savetxt('generalresponses.data',responses)\n</code></pre>\n\n<hr>\n\n<p><strong>Now we enter in to training and testing part.</strong></p>\n\n<p>For testing part I used below image, which has same type of letters I used to train.</p>\n\n<p><img src=\"https://i.stack.imgur.com/dPaE8.png\" alt=\"enter image description here\"></p>\n\n<p><strong>For training we do as follows</strong>:</p>\n\n<ol>\n<li>Load the txt files we already saved earlier</li>\n<li>create a instance of classifier we are using ( here, it is KNearest)</li>\n<li>Then we use KNearest.train function to train the data</li>\n</ol>\n\n<p><strong>For testing purposes, we do as follows:</strong></p>\n\n<ol>\n<li>We load the image used for testing</li>\n<li>process the image as earlier and extract each digit using contour methods</li>\n<li>Draw bounding box for it, then resize to 10x10, and store its pixel values in an array as done earlier. </li>\n<li>Then we use KNearest.find_nearest() function to find the nearest item to the one we gave. ( If lucky, it recognises the correct digit.)</li>\n</ol>\n\n<p>I included last two steps ( training and testing) in single code below:</p>\n\n<pre><code>import cv2\nimport numpy as np\n\n#######   training part    ############### \nsamples = np.loadtxt('generalsamples.data',np.float32)\nresponses = np.loadtxt('generalresponses.data',np.float32)\nresponses = responses.reshape((responses.size,1))\n\nmodel = cv2.KNearest()\nmodel.train(samples,responses)\n\n############################# testing part  #########################\n\nim = cv2.imread('pi.png')\nout = np.zeros(im.shape,np.uint8)\ngray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)\nthresh = cv2.adaptiveThreshold(gray,255,1,1,11,2)\n\ncontours,hierarchy = cv2.findContours(thresh,cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)\n\nfor cnt in contours:\n    if cv2.contourArea(cnt)&gt;50:\n        [x,y,w,h] = cv2.boundingRect(cnt)\n        if  h&gt;28:\n            cv2.rectangle(im,(x,y),(x+w,y+h),(0,255,0),2)\n            roi = thresh[y:y+h,x:x+w]\n            roismall = cv2.resize(roi,(10,10))\n            roismall = roismall.reshape((1,100))\n            roismall = np.float32(roismall)\n            retval, results, neigh_resp, dists = model.find_nearest(roismall, k = 1)\n            string = str(int((results[0][0])))\n            cv2.putText(out,string,(x,y+h),0,1,(0,255,0))\n\ncv2.imshow('im',im)\ncv2.imshow('out',out)\ncv2.waitKey(0)\n</code></pre>\n\n<p>And it worked, below is the result I got:</p>\n\n<p><img src=\"https://i.stack.imgur.com/xS3gF.png\" alt=\"enter image description here\"></p>\n\n<hr>\n\n<p>Here it worked with 100% accuracy. I assume this is because all the digits are of same kind and same size.</p>\n\n<p>But any way, this is a good start to go for beginners ( I hope so).</p>\n"}, {"title": "What does -1 mean in numpy reshape?", "question_body": "<p>A numpy matrix can be reshaped into a vector using reshape function with parameter -1. But I don't know what -1 means here.</p>\n\n<p>For example: </p>\n\n<pre><code>a = numpy.matrix([[1, 2, 3, 4], [5, 6, 7, 8]])\nb = numpy.reshape(a, -1)\n</code></pre>\n\n<p>The result of <code>b</code> is: <code>matrix([[1, 2, 3, 4, 5, 6, 7, 8]])</code></p>\n\n<p>Does anyone know what -1 means here?\nAnd it seems python assign -1 several meanings, such as: <code>array[-1]</code> means the last element. Can you give an explanation?</p>\n", "link": "https://stackoverflow.com/questions/18691084/what-does-1-mean-in-numpy-reshape", "question_id": 18691084, "accepted_answer_id": null}, {"title": "Numpy array dimensions", "question_body": "<p>I'm currently trying to learn Numpy and Python. Given the following array:</p>\n\n<pre><code>import numpy as np\na = np.array([[1,2],[1,2]])\n</code></pre>\n\n<p>Is there a function that returns the dimensions of <code>a</code> (e.g.a is a 2 by 2 array)?</p>\n\n<p><code>size()</code> returns 4 and that doesn't help very much. </p>\n", "link": "https://stackoverflow.com/questions/3061761/numpy-array-dimensions", "question_id": 3061761, "accepted_answer_id": 3061789, "answer_body": "<p>It is <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape\" rel=\"noreferrer\"><code>.shape</code></a>:</p>\n\n<blockquote>\n  <p>ndarray.<strong>shape</strong><br>\n  Tuple of array dimensions.</p>\n</blockquote>\n\n<p>Thus:</p>\n\n<pre><code>&gt;&gt;&gt; a.shape\n(2, 2)\n</code></pre>\n"}, {"title": "Reloading submodules in IPython", "question_body": "<p>Currently I am working on a python project that contains sub modules and uses numpy/scipy. Ipython is used as interactive console. Unfortunately I am not very happy with workflow that I am using right now, I would appreciate some advice.</p>\n\n<p>In IPython, the framework is loaded by a simple <code>import</code> command. However, it is often necessary to change code in one of the submodules of the framework. At this point a model is already loaded and I use IPython to interact with it. </p>\n\n<p>Now, the framework contains many modules that depend on each other, i.e. when the framework is initially loaded the main module is importing and configuring the submodules.  The changes to the code are only executed if the module is reloaded using <code>reload(main_mod.sub_mod)</code>. This is cumbersome as I need to reload all changed modules individually using the full path. It would be very convenient if <code>reload(main_module)</code> would also reload all sub modules, but without reloading numpy/scipy..</p>\n", "link": "https://stackoverflow.com/questions/5364050/reloading-submodules-in-ipython", "question_id": 5364050, "accepted_answer_id": 5399339, "answer_body": "<p>IPython comes with some <a href=\"http://ipython.readthedocs.io/en/stable/config/extensions/autoreload.html\" rel=\"noreferrer\">automatic reloading</a> magic:</p>\n\n<pre><code>%load_ext autoreload\n%autoreload 2\n</code></pre>\n\n<p>It will reload all changed modules every time before executing a new line. The way this works is slightly different than <code>dreload</code>. Some caveats apply, type <code>%autoreload?</code> to see what can go wrong.</p>\n\n<hr>\n\n<p>If you want to always enable this settings, modify your IPython configuration file <code>~/.ipython/profile_default/ipython_config.py</code>[1] and appending:</p>\n\n<pre><code>c.InteractiveShellApp.extensions = ['autoreload']     \nc.InteractiveShellApp.exec_lines = ['%autoreload 2']\n</code></pre>\n\n<p><em>Credit to @Kos via a comment below.</em></p>\n\n<p>[1]\nIf you don't have the file <code>~/.ipython/profile_default/ipython_config.py</code>, you need to call <code>ipython profile create</code> first. Or the file may be located at <code>$IPYTHONDIR</code>.</p>\n"}, {"title": "What are the differences between numpy arrays and matrices? Which one should I use?", "question_body": "<p>What are the advantages and disadvantages of each?</p>\n\n<p>From what I've seen, either one can work as a replacement for the other if need be, so should I bother using both or should I stick to just one of them?</p>\n\n<p>Will the style of the program influence my choice? I am doing some machine learning using numpy, so there are indeed lots of matrices, but also lots of vectors (arrays).</p>\n", "link": "https://stackoverflow.com/questions/4151128/what-are-the-differences-between-numpy-arrays-and-matrices-which-one-should-i-u", "question_id": 4151128, "accepted_answer_id": 4151251, "answer_body": "<p>Numpy matrices are strictly 2-dimensional, while numpy arrays (ndarrays) are\nN-dimensional.  Matrix objects are a subclass of ndarray, so they inherit all\nthe attributes and methods of ndarrays.</p>\n\n<p>The main advantage of numpy matrices is that they provide a convenient notation\nfor matrix multiplication: if a and b are matrices, then a*b is their matrix\nproduct.</p>\n\n<pre><code>import numpy as np\n\na=np.mat('4 3; 2 1')\nb=np.mat('1 2; 3 4')\nprint(a)\n# [[4 3]\n#  [2 1]]\nprint(b)\n# [[1 2]\n#  [3 4]]\nprint(a*b)\n# [[13 20]\n#  [ 5  8]]\n</code></pre>\n\n<p>On the other hand, as of Python 3.5, NumPy supports infix matrix multiplication using the <code>@</code> operator, so you can achieve the same convenience of matrix multiplication with ndarrays in Python >= 3.5.</p>\n\n<pre><code>import numpy as np\n\na=np.array([[4, 3], [2, 1]])\nb=np.array([[1, 2], [3, 4]])\nprint(a@b)\n# [[13 20]\n#  [ 5  8]]\n</code></pre>\n\n<p>Both matrix objects and ndarrays have <code>.T</code> to return the transpose, but matrix\nobjects also have <code>.H</code> for the conjugate transpose, and <code>.I</code> for the inverse.</p>\n\n<p>In contrast, numpy arrays consistently abide by the rule that operations are\napplied element-wise (except for the new <code>@</code> operator). Thus, if <code>a</code> and <code>b</code> are numpy arrays, then <code>a*b</code> is the array\nformed by multiplying the components element-wise:</p>\n\n<pre><code>c=np.array([[4, 3], [2, 1]])\nd=np.array([[1, 2], [3, 4]])\nprint(c*d)\n# [[4 6]\n#  [6 4]]\n</code></pre>\n\n<p>To obtain the result of matrix multiplication, you use <code>np.dot</code> (or <code>@</code> in Python >= 3.5, as shown above):</p>\n\n<pre><code>print(np.dot(c,d))\n# [[13 20]\n#  [ 5  8]]\n</code></pre>\n\n<p>The <code>**</code> operator also behaves differently:</p>\n\n<pre><code>print(a**2)\n# [[22 15]\n#  [10  7]]\nprint(c**2)\n# [[16  9]\n#  [ 4  1]]\n</code></pre>\n\n<p>Since <code>a</code> is a matrix, <code>a**2</code> returns the matrix product <code>a*a</code>.\nSince <code>c</code> is an ndarray, <code>c**2</code> returns an ndarray with each component squared\nelement-wise.</p>\n\n<p>There are other technical differences between matrix objects and ndarrays\n(having to do with np.ravel, item selection and sequence behavior).</p>\n\n<p>The main advantage of numpy arrays is that they are more general than\n2-dimensional matrices. What happens when you want a 3-dimensional array? Then\nyou have to use an ndarray, not a matrix object. Thus, learning to use matrix\nobjects is more work -- you have to learn matrix object operations, and\nndarray operations.</p>\n\n<p>Writing a program that uses both matrices and arrays makes your life difficult\nbecause you have to keep track of what type of object your variables are, lest\nmultiplication return something you don't expect.</p>\n\n<p>In contrast, if you stick solely with ndarrays, then you can do everything\nmatrix objects can do, and more, except with slightly different\nfunctions/notation.</p>\n\n<p>If you are willing to give up the visual appeal of NumPy matrix product\nnotation (which can be achieved almost as elegantly with ndarrays in Python >= 3.5), then I think NumPy arrays are definitely the way to go.</p>\n\n<p>PS. Of course, you really don't have to choose one at the expense of the other,\nsince <code>np.asmatrix</code> and <code>np.asarray</code> allow you to convert one to the other (as\nlong as the array is 2-dimensional).</p>\n\n<hr>\n\n<p>There is a synopsis of the differences between NumPy <code>arrays</code> vs NumPy <code>matrix</code>es <a href=\"https://www.numpy.org/devdocs/user/numpy-for-matlab-users.html#array-or-matrix-which-should-i-use\" rel=\"noreferrer\">here</a>.</p>\n"}, {"title": "Find nearest value in numpy array", "question_body": "<p>Is there a numpy-thonic way, e.g. function, to find the <em>nearest value</em> in an array? </p>\n\n<p>Example:</p>\n\n<pre><code>np.find_nearest( array, value )\n</code></pre>\n", "link": "https://stackoverflow.com/questions/2566412/find-nearest-value-in-numpy-array", "question_id": 2566412, "accepted_answer_id": 2566508, "answer_body": "<pre><code>import numpy as np\ndef find_nearest(array, value):\n    array = np.asarray(array)\n    idx = (np.abs(array - value)).argmin()\n    return array[idx]\n\narray = np.random.random(10)\nprint(array)\n# [ 0.21069679  0.61290182  0.63425412  0.84635244  0.91599191  0.00213826\n#   0.17104965  0.56874386  0.57319379  0.28719469]\n\nvalue = 0.5\n\nprint(find_nearest(array, value))\n# 0.568743859261\n</code></pre>\n"}, {"title": "Sorting arrays in NumPy by column", "question_body": "<p>How can I sort an array in NumPy by the nth column?</p>\n\n<p>For example,</p>\n\n<pre><code>a = array([[9, 2, 3],\n           [4, 5, 6],\n           [7, 0, 5]])\n</code></pre>\n\n<p>I'd like to sort rows by the second column, such that I get back:</p>\n\n<pre><code>array([[7, 0, 5],\n       [9, 2, 3],\n       [4, 5, 6]])\n</code></pre>\n", "link": "https://stackoverflow.com/questions/2828059/sorting-arrays-in-numpy-by-column", "question_id": 2828059, "accepted_answer_id": 2828371, "answer_body": "<p><a href=\"https://stackoverflow.com/users/208339/steve-tjoa\">@steve</a>'s is actually the most elegant way of doing it.</p>\n\n<p>For the \"correct\" way see the order keyword argument of <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.sort.html#numpy.ndarray.sort\" rel=\"noreferrer\">numpy.ndarray.sort</a> </p>\n\n<p>However, you'll need to view your array as an array with fields (a structured array).</p>\n\n<p>The \"correct\" way is quite ugly if you didn't initially define your array with fields...</p>\n\n<p>As a quick example, to sort it and return a copy:</p>\n\n<pre><code>In [1]: import numpy as np\n\nIn [2]: a = np.array([[1,2,3],[4,5,6],[0,0,1]])\n\nIn [3]: np.sort(a.view('i8,i8,i8'), order=['f1'], axis=0).view(np.int)\nOut[3]: \narray([[0, 0, 1],\n       [1, 2, 3],\n       [4, 5, 6]])\n</code></pre>\n\n<p>To sort it in-place:</p>\n\n<pre><code>In [6]: a.view('i8,i8,i8').sort(order=['f1'], axis=0) #&lt;-- returns None\n\nIn [7]: a\nOut[7]: \narray([[0, 0, 1],\n       [1, 2, 3],\n       [4, 5, 6]])\n</code></pre>\n\n<p>@Steve's really is the most elegant way to do it, as far as I know... </p>\n\n<p>The only advantage to this method is that the \"order\" argument is a list of the fields to order the search by. For example, you can sort by the second column, then the third column, then the first column by supplying order=['f1','f2','f0'].</p>\n"}, {"title": "How to pretty-print a numpy.array without scientific notation and with given precision?", "question_body": "<p>I'm curious, whether there is any way to print formatted <code>numpy.arrays</code>, e.g., in a way similar to this:</p>\n\n<pre><code>x = 1.23456\nprint '%.3f' % x\n</code></pre>\n\n<p>If I want to print the <code>numpy.array</code> of floats, it prints several decimals, often in 'scientific' format, which is rather hard to read even for low-dimensional arrays. However, <code>numpy.array</code> apparently has to be printed as a string, i.e., with <code>%s</code>. Is there a solution for this? </p>\n", "link": "https://stackoverflow.com/questions/2891790/how-to-pretty-print-a-numpy-array-without-scientific-notation-and-with-given-pre", "question_id": 2891790, "accepted_answer_id": 2891805, "answer_body": "<p>You can use <code>set_printoptions</code> to set the precision of the output:</p>\n\n<pre><code>import numpy as np\nx=np.random.random(10)\nprint(x)\n# [ 0.07837821  0.48002108  0.41274116  0.82993414  0.77610352  0.1023732\n#   0.51303098  0.4617183   0.33487207  0.71162095]\n\nnp.set_printoptions(precision=3)\nprint(x)\n# [ 0.078  0.48   0.413  0.83   0.776  0.102  0.513  0.462  0.335  0.712]\n</code></pre>\n\n<p>And <code>suppress</code> suppresses the use of scientific notation for small numbers:</p>\n\n<pre><code>y=np.array([1.5e-10,1.5,1500])\nprint(y)\n# [  1.500e-10   1.500e+00   1.500e+03]\nnp.set_printoptions(suppress=True)\nprint(y)\n# [    0.      1.5  1500. ]\n</code></pre>\n\n<p>See the <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html\" rel=\"noreferrer\">docs for set_printoptions</a> for other options.</p>\n\n<hr>\n\n<p><strong>To apply print options locally</strong>, using NumPy 1.15.0 or later, you could use the <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.printoptions.html\" rel=\"noreferrer\">numpy.printoptions</a> context manager. \nFor example, inside the <code>with-suite</code> <code>precision=3</code> and <code>suppress=True</code> are set:</p>\n\n<pre><code>x = np.random.random(10)\nwith np.printoptions(precision=3, suppress=True):\n    print(x)\n    # [ 0.073  0.461  0.689  0.754  0.624  0.901  0.049  0.582  0.557  0.348]\n</code></pre>\n\n<p>But outside the <code>with-suite</code> the print options are back to default settings:</p>\n\n<pre><code>print(x)    \n# [ 0.07334334  0.46132615  0.68935231  0.75379645  0.62424021  0.90115836\n#   0.04879837  0.58207504  0.55694118  0.34768638]\n</code></pre>\n\n<p>If you are using an earlier version of NumPy, you can create the context manager\nyourself. For example,</p>\n\n<pre><code>import numpy as np\nimport contextlib\n\n@contextlib.contextmanager\ndef printoptions(*args, **kwargs):\n    original = np.get_printoptions()\n    np.set_printoptions(*args, **kwargs)\n    try:\n        yield\n    finally: \n        np.set_printoptions(**original)\n\nx = np.random.random(10)\nwith printoptions(precision=3, suppress=True):\n    print(x)\n    # [ 0.073  0.461  0.689  0.754  0.624  0.901  0.049  0.582  0.557  0.348]\n</code></pre>\n\n<hr>\n\n<p><strong>To prevent zeros from being stripped from the end of floats:</strong></p>\n\n<p><code>np.set_printoptions</code> now has a <code>formatter</code> parameter which allows you to specify a format function for each type.</p>\n\n<pre><code>np.set_printoptions(formatter={'float': '{: 0.3f}'.format})\nprint(x)\n</code></pre>\n\n<p>which prints</p>\n\n<pre><code>[ 0.078  0.480  0.413  0.830  0.776  0.102  0.513  0.462  0.335  0.712]\n</code></pre>\n\n<p>instead of </p>\n\n<pre><code>[ 0.078  0.48   0.413  0.83   0.776  0.102  0.513  0.462  0.335  0.712]\n</code></pre>\n"}, {"title": "How to count the occurrence of certain item in an ndarray in Python?", "question_body": "<p>In Python, I have an ndarray <code>y</code>\nthat is printed as <code>array([0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1])</code></p>\n\n<p>I'm trying to count how many <code>0</code>s and how many <code>1</code>s are there in this array. </p>\n\n<p>But when I type <code>y.count(0)</code> or <code>y.count(1)</code>, it says </p>\n\n<blockquote>\n  <p><code>numpy.ndarray</code> object has no attribute <code>count</code></p>\n</blockquote>\n\n<p>What should I do? </p>\n", "link": "https://stackoverflow.com/questions/28663856/how-to-count-the-occurrence-of-certain-item-in-an-ndarray-in-python", "question_id": 28663856, "accepted_answer_id": 28663910, "answer_body": "<pre><code>&gt;&gt;&gt; a = numpy.array([0, 3, 0, 1, 0, 1, 2, 1, 0, 0, 0, 0, 1, 3, 4])\n&gt;&gt;&gt; unique, counts = numpy.unique(a, return_counts=True)\n&gt;&gt;&gt; dict(zip(unique, counts))\n{0: 7, 1: 4, 2: 1, 3: 2, 4: 1}\n</code></pre>\n\n<p><strong>Non-numpy way</strong>:</p>\n\n<p>Use <a href=\"https://docs.python.org/2/library/collections.html#collections.Counter\" rel=\"noreferrer\"><code>collections.Counter</code></a>;</p>\n\n<pre><code>&gt;&gt; import collections, numpy\n\n&gt;&gt;&gt; a = numpy.array([0, 3, 0, 1, 0, 1, 2, 1, 0, 0, 0, 0, 1, 3, 4])\n&gt;&gt;&gt; collections.Counter(a)\nCounter({0: 7, 1: 4, 3: 2, 2: 1, 4: 1})\n</code></pre>\n"}, {"title": "How do I create an empty array/matrix in NumPy?", "question_body": "<p>I can't figure out how to use an array or matrix in the way that I would normally use a list. I want to create an empty array (or matrix) and then add one column (or row) to it at a time.</p>\n\n<p>At the moment the only way I can find to do this is like:</p>\n\n<pre><code>mat = None\nfor col in columns:\n    if mat is None:\n        mat = col\n    else:\n        mat = hstack((mat, col))\n</code></pre>\n\n<p>Whereas if it were a list, I'd do something like this:</p>\n\n<pre><code>list = []\nfor item in data:\n    list.append(item)\n</code></pre>\n\n<p>Is there a way to use that kind of notation for <a href=\"http://en.wikipedia.org/wiki/NumPy\" rel=\"noreferrer\">NumPy</a> arrays or matrices?</p>\n", "link": "https://stackoverflow.com/questions/568962/how-do-i-create-an-empty-array-matrix-in-numpy", "question_id": 568962, "accepted_answer_id": 569063, "answer_body": "<p>You have the wrong mental model for using NumPy efficiently. NumPy arrays are stored in contiguous blocks of memory. If you want to add rows or columns to an existing array, the entire array needs to be copied to a new block of memory, creating gaps for the new elements to be stored. This is very inefficient if done repeatedly to build an array.</p>\n\n<p>In the case of adding rows, your best bet is to create an array that is as big as your data set will eventually be, and then add data to it row-by-row:</p>\n\n<pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; a = numpy.zeros(shape=(5,2))\n&gt;&gt;&gt; a\narray([[ 0.,  0.],\n   [ 0.,  0.],\n   [ 0.,  0.],\n   [ 0.,  0.],\n   [ 0.,  0.]])\n&gt;&gt;&gt; a[0] = [1,2]\n&gt;&gt;&gt; a[1] = [2,3]\n&gt;&gt;&gt; a\narray([[ 1.,  2.],\n   [ 2.,  3.],\n   [ 0.,  0.],\n   [ 0.,  0.],\n   [ 0.,  0.]])\n</code></pre>\n"}, {"title": "Difference between numpy.array shape (R, 1) and (R,)", "question_body": "<p>In <code>numpy</code>, some of the operations return in shape <code>(R, 1)</code> but some return <code>(R,)</code>. This will make matrix multiplication more tedious since explicit <code>reshape</code> is required. For example, given a matrix <code>M</code>, if we want to do <code>numpy.dot(M[:,0], numpy.ones((1, R)))</code> where <code>R</code> is the number of rows (of course, the same issue also occurs column-wise). We will get <code>matrices are not aligned</code> error since <code>M[:,0]</code> is in shape <code>(R,)</code> but <code>numpy.ones((1, R))</code> is in shape <code>(1, R)</code>.</p>\n\n<p>So my questions are:</p>\n\n<ol>\n<li><p>What's the difference between shape <code>(R, 1)</code> and <code>(R,)</code>. I know literally it's list of numbers and list of lists where all list contains only a number. Just wondering why not design <code>numpy</code> so that it favors shape <code>(R, 1)</code> instead of <code>(R,)</code> for easier matrix multiplication.</p></li>\n<li><p>Are there better ways for the above example? Without explicitly reshape like this: <code>numpy.dot(M[:,0].reshape(R, 1), numpy.ones((1, R)))</code></p></li>\n</ol>\n", "link": "https://stackoverflow.com/questions/22053050/difference-between-numpy-array-shape-r-1-and-r", "question_id": 22053050, "accepted_answer_id": 22074424, "answer_body": "<h3>1. The meaning of shapes in NumPy</h3>\n\n<p>You write, \"I know literally it's list of numbers and list of lists where all list contains only a number\" but that's a bit of an unhelpful way to think about it.</p>\n\n<p>The best way to think about NumPy arrays is that they consist of two parts, a <em>data buffer</em> which is just a block of raw elements, and a <em>view</em> which describes how to interpret the data buffer.</p>\n\n<p>For example, if we create an array of 12 integers:</p>\n\n<pre><code>&gt;&gt;&gt; a = numpy.arange(12)\n&gt;&gt;&gt; a\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n</code></pre>\n\n<p>Then <code>a</code> consists of a data buffer, arranged something like this:</p>\n\n<pre><code>\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502  0 \u2502  1 \u2502  2 \u2502  3 \u2502  4 \u2502  5 \u2502  6 \u2502  7 \u2502  8 \u2502  9 \u2502 10 \u2502 11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n\n<p>and a view which describes how to interpret the data:</p>\n\n<pre><code>&gt;&gt;&gt; a.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; a.dtype\ndtype('int64')\n&gt;&gt;&gt; a.itemsize\n8\n&gt;&gt;&gt; a.strides\n(8,)\n&gt;&gt;&gt; a.shape\n(12,)\n</code></pre>\n\n<p>Here the <em>shape</em> <code>(12,)</code> means the array is indexed by a single index which runs from 0\u00a0to\u00a011. Conceptually, if we label this single index <code>i</code>, the array <code>a</code> looks like this:</p>\n\n<pre><code>i= 0    1    2    3    4    5    6    7    8    9   10   11\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502  0 \u2502  1 \u2502  2 \u2502  3 \u2502  4 \u2502  5 \u2502  6 \u2502  7 \u2502  8 \u2502  9 \u2502 10 \u2502 11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n\n<p>If we <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html\" rel=\"noreferrer\">reshape</a> an array, this doesn't change the data buffer. Instead, it creates a new view that describes a different way to interpret the data. So after:</p>\n\n<pre><code>&gt;&gt;&gt; b = a.reshape((3, 4))\n</code></pre>\n\n<p>the array <code>b</code> has the same data buffer as <code>a</code>, but now it is indexed by <em>two</em> indices which run from 0\u00a0to\u00a02 and 0\u00a0to\u00a03 respectively. If we label the two indices <code>i</code> and <code>j</code>, the array <code>b</code> looks like this:</p>\n\n<pre><code>i= 0    0    0    0    1    1    1    1    2    2    2    2\nj= 0    1    2    3    0    1    2    3    0    1    2    3\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502  0 \u2502  1 \u2502  2 \u2502  3 \u2502  4 \u2502  5 \u2502  6 \u2502  7 \u2502  8 \u2502  9 \u2502 10 \u2502 11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n\n<p>which means that:</p>\n\n<pre><code>&gt;&gt;&gt; b[2,1]\n9\n</code></pre>\n\n<p>You can see that the second index changes quickly and the first index changes slowly. If you prefer this to be the other way round, you can specify the <code>order</code> parameter:</p>\n\n<pre><code>&gt;&gt;&gt; c = a.reshape((3, 4), order='F')\n</code></pre>\n\n<p>which results in an array indexed like this:</p>\n\n<pre><code>i= 0    1    2    0    1    2    0    1    2    0    1    2\nj= 0    0    0    1    1    1    2    2    2    3    3    3\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502  0 \u2502  1 \u2502  2 \u2502  3 \u2502  4 \u2502  5 \u2502  6 \u2502  7 \u2502  8 \u2502  9 \u2502 10 \u2502 11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n\n<p>which means that:</p>\n\n<pre><code>&gt;&gt;&gt; c[2,1]\n5\n</code></pre>\n\n<p>It should now be clear what it means for an array to have a shape with one or more dimensions of size\u00a01. After:</p>\n\n<pre><code>&gt;&gt;&gt; d = a.reshape((12, 1))\n</code></pre>\n\n<p>the array <code>d</code> is indexed by two indices, the first of which runs from 0\u00a0to\u00a011, and the second index is always\u00a00:</p>\n\n<pre><code>i= 0    1    2    3    4    5    6    7    8    9   10   11\nj= 0    0    0    0    0    0    0    0    0    0    0    0\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502  0 \u2502  1 \u2502  2 \u2502  3 \u2502  4 \u2502  5 \u2502  6 \u2502  7 \u2502  8 \u2502  9 \u2502 10 \u2502 11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n\n<p>and so:</p>\n\n<pre><code>&gt;&gt;&gt; d[10,0]\n10\n</code></pre>\n\n<p>A dimension of length\u00a01 is \"free\" (in some sense), so there's nothing stopping you from going to town:</p>\n\n<pre><code>&gt;&gt;&gt; e = a.reshape((1, 2, 1, 6, 1))\n</code></pre>\n\n<p>giving an array indexed like this:</p>\n\n<pre><code>i= 0    0    0    0    0    0    0    0    0    0    0    0\nj= 0    0    0    0    0    0    1    1    1    1    1    1\nk= 0    0    0    0    0    0    0    0    0    0    0    0\nl= 0    1    2    3    4    5    0    1    2    3    4    5\nm= 0    0    0    0    0    0    0    0    0    0    0    0\n\u250c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n\u2502  0 \u2502  1 \u2502  2 \u2502  3 \u2502  4 \u2502  5 \u2502  6 \u2502  7 \u2502  8 \u2502  9 \u2502 10 \u2502 11 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\n</code></pre>\n\n<p>and so:</p>\n\n<pre><code>&gt;&gt;&gt; e[0,1,0,0,0]\n6\n</code></pre>\n\n<p>See the <a href=\"http://docs.scipy.org/doc/numpy/reference/internals.html\" rel=\"noreferrer\">NumPy internals documentation</a> for more details about how arrays are implemented.</p>\n\n<h3>2. What to do?</h3>\n\n<p>Since <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html\" rel=\"noreferrer\"><code>numpy.reshape</code></a> just creates a new view, you shouldn't be scared about using it whenever necessary. It's the right tool to use when you want to index an array in a different way.</p>\n\n<p>However, in a long computation it's usually possible to arrange to construct arrays with the \"right\" shape in the first place, and so minimize the number of reshapes and transposes. But without seeing the actual context that led to the need for a reshape, it's hard to say what should be changed.</p>\n\n<p>The example in your question is:</p>\n\n<pre><code>numpy.dot(M[:,0], numpy.ones((1, R)))\n</code></pre>\n\n<p>but this is not realistic. First, this expression:</p>\n\n<pre><code>M[:,0].sum()\n</code></pre>\n\n<p>computes the result more simply. Second, is there really something special about column 0? Perhaps what you actually need is:</p>\n\n<pre><code>M.sum(axis=0)\n</code></pre>\n"}, {"title": "How to add an extra column to a NumPy array", "question_body": "<p>Let\u2019s say I have a NumPy array, <code>a</code>:</p>\n\n\n\n<pre><code>a = np.array([\n    [1, 2, 3],\n    [2, 3, 4]\n    ])\n</code></pre>\n\n<p>And I would like to add a column of zeros to get an array, <code>b</code>:</p>\n\n\n\n<pre><code>b = np.array([\n    [1, 2, 3, 0],\n    [2, 3, 4, 0]\n    ])\n</code></pre>\n\n<p>How can I do this easily in NumPy?</p>\n", "link": "https://stackoverflow.com/questions/8486294/how-to-add-an-extra-column-to-a-numpy-array", "question_id": 8486294, "accepted_answer_id": 8489498, "answer_body": "<p>I think a more straightforward solution and faster to boot is to do the following:</p>\n\n<pre><code>import numpy as np\nN = 10\na = np.random.rand(N,N)\nb = np.zeros((N,N+1))\nb[:,:-1] = a\n</code></pre>\n\n<p>And timings:</p>\n\n<pre><code>In [23]: N = 10\n\nIn [24]: a = np.random.rand(N,N)\n\nIn [25]: %timeit b = np.hstack((a,np.zeros((a.shape[0],1))))\n10000 loops, best of 3: 19.6 us per loop\n\nIn [27]: %timeit b = np.zeros((a.shape[0],a.shape[1]+1)); b[:,:-1] = a\n100000 loops, best of 3: 5.62 us per loop\n</code></pre>\n"}, {"title": "How to convert 2D float numpy array to 2D int numpy array?", "question_body": "<p>How to convert real numpy array to int numpy array?\nTried using map directly to array but it did not work.</p>\n", "link": "https://stackoverflow.com/questions/10873824/how-to-convert-2d-float-numpy-array-to-2d-int-numpy-array", "question_id": 10873824, "accepted_answer_id": 10873843, "answer_body": "<p>Use the <a href=\"https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.ndarray.astype.html\" rel=\"noreferrer\"><code>astype</code></a> method.</p>\n\n<pre><code>&gt;&gt;&gt; x = np.array([[1.0, 2.3], [1.3, 2.9]])\n&gt;&gt;&gt; x\narray([[ 1. ,  2.3],\n       [ 1.3,  2.9]])\n&gt;&gt;&gt; x.astype(int)\narray([[1, 2],\n       [1, 2]])\n</code></pre>\n"}, {"title": "Converting NumPy array into Python List structure?", "question_body": "<p>How do I convert a <a href=\"http://en.wikipedia.org/wiki/NumPy\" rel=\"noreferrer\">NumPy</a> array to a Python List (for example <code>[[1,2,3],[4,5,6]]</code> ), and do it reasonably fast?</p>\n", "link": "https://stackoverflow.com/questions/1966207/converting-numpy-array-into-python-list-structure", "question_id": 1966207, "accepted_answer_id": 1966210, "answer_body": "<p>Use <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tolist.html\" rel=\"noreferrer\"><code>tolist()</code></a>:</p>\n\n<pre><code>import numpy as np\n&gt;&gt;&gt; np.array([[1,2,3],[4,5,6]]).tolist()\n[[1, 2, 3], [4, 5, 6]]\n</code></pre>\n\n<p>Note that this converts the values from whatever numpy type they may have (e.g. np.int32 or np.float32) to the \"nearest compatible Python type\" (in a list). If you want to preserve the numpy data types, you could call list() on your array instead, and you'll end up with a list of <a href=\"https://docs.scipy.org/doc/numpy-1.10.0/reference/arrays.scalars.html\" rel=\"noreferrer\">numpy scalars</a>. (Thanks to Mr_and_Mrs_D for pointing that out in a comment.)</p>\n"}, {"title": "Pandas read_csv low_memory and dtype options", "question_body": "<p>When calling</p>\n\n<pre><code>df = pd.read_csv('somefile.csv')\n</code></pre>\n\n<p>I get:</p>\n\n<blockquote>\n  <p>/Users/josh/anaconda/envs/py27/lib/python2.7/site-packages/pandas/io/parsers.py:1130:\n  DtypeWarning: Columns (4,5,7,16) have mixed types.  Specify dtype\n  option on import or set low_memory=False.</p>\n</blockquote>\n\n<p>Why is the <code>dtype</code> option related to <code>low_memory</code>, and why would making it <code>False</code> help with this problem?</p>\n", "link": "https://stackoverflow.com/questions/24251219/pandas-read-csv-low-memory-and-dtype-options", "question_id": 24251219, "accepted_answer_id": 27232309, "answer_body": "<h1>The deprecated low_memory option</h1>\n\n<p>The <code>low_memory</code> option is not properly deprecated, but it should be, since it does not actually do anything differently[<a href=\"https://github.com/pydata/pandas/issues/5888\" rel=\"noreferrer\">source</a>]</p>\n\n<p>The reason you get this <code>low_memory</code> warning is because guessing dtypes for each column is very memory demanding. Pandas tries to determine what dtype to set by analyzing the data in each column.</p>\n\n<h1>Dtype Guessing (very bad)</h1>\n\n<p>Pandas can only determine what dtype a column should have once the whole file is read. This means nothing can really be parsed before the whole file is read unless you risk having to change the dtype of that column when you read the last value.</p>\n\n<p>Consider the example of one file which has a column called user_id.\nIt contains 10 million rows where the user_id is always numbers.\nSince pandas cannot know it is only numbers, it will probably keep it as the original strings until it has read the whole file.</p>\n\n<h1>Specifying dtypes (should always be done)</h1>\n\n<p>adding</p>\n\n<pre><code>dtype={'user_id': int}\n</code></pre>\n\n<p>to the <a href=\"http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html\" rel=\"noreferrer\"><code>pd.read_csv()</code></a> call will make pandas know when it starts reading the file, that this is only integers.</p>\n\n<p>Also worth noting is that if the last line in the file would have <code>\"foobar\"</code> written in the <code>user_id</code> column, the loading would crash if the above dtype was specified.</p>\n\n<h3>Example of broken data that breaks when dtypes are defined</h3>\n\n<pre><code>import pandas as pd\ntry:\n    from StringIO import StringIO\nexcept ImportError:\n    from io import StringIO\n\n\ncsvdata = \"\"\"user_id,username\n1,Alice\n3,Bob\nfoobar,Caesar\"\"\"\nsio = StringIO(csvdata)\npd.read_csv(sio, dtype={\"user_id\": int, \"username\": object})\n\nValueError: invalid literal for long() with base 10: 'foobar'\n</code></pre>\n\n<p>dtypes are typically a numpy thing, read more about them here:\n<a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html\" rel=\"noreferrer\">http://docs.scipy.org/doc/numpy/reference/generated/numpy.dtype.html</a></p>\n\n<h1>What dtypes exists?</h1>\n\n<p>These are the numpy dtypes that are also accepted in pandas</p>\n\n<pre><code>[numpy.generic,\n [[numpy.number,\n   [[numpy.integer,\n     [[numpy.signedinteger,\n       [numpy.int8,\n        numpy.int16,\n        numpy.int32,\n        numpy.int64,\n        numpy.int64,\n        numpy.timedelta64]],\n      [numpy.unsignedinteger,\n       [numpy.uint8,\n        numpy.uint16,\n        numpy.uint32,\n        numpy.uint64,\n        numpy.uint64]]]],\n    [numpy.inexact,\n     [[numpy.floating,\n       [numpy.float16, numpy.float32, numpy.float64, numpy.float128]],\n      [numpy.complexfloating,\n       [numpy.complex64, numpy.complex128, numpy.complex256]]]]]],\n  [numpy.flexible,\n   [[numpy.character, [numpy.bytes_, numpy.str_]],\n    [numpy.void, [numpy.record]]]],\n  numpy.bool_,\n  numpy.datetime64,\n  numpy.object_]]\n</code></pre>\n\n<p>Pandas also adds two dtypes: <code>categorical</code> and <code>datetime64[ns, tz]</code> that are not available in numpy</p>\n\n<p><a href=\"http://pandas.pydata.org/pandas-docs/stable/getting_started/basics.html#dtypes\" rel=\"noreferrer\">Pandas dtype reference</a></p>\n\n<h1>Gotchas, caveats, notes</h1>\n\n<p>Setting <code>dtype=object</code> will silence the above warning, but will not make it more memory efficient, only process efficient if anything.</p>\n\n<p>Setting <code>dtype=unicode</code> will not do anything, since to numpy, a <code>unicode</code> is represented as <code>object</code>.</p>\n\n<h3>Usage of converters</h3>\n\n<p>@sparrow correctly points out the usage of converters to avoid pandas blowing up when encountering <code>'foobar'</code> in a column specified as <code>int</code>. I would like to add that converters are really heavy and inefficient to use in pandas and should be used as a last resort. This is because the read_csv process is a single process.</p>\n\n<p>CSV files can be processed line by line and thus can be processed by multiple converters in parallel more efficiently by simply cutting the file into segments and running multiple processes, something that pandas does not support. But this is a different story.</p>\n"}, {"title": "What is the difference between flatten and ravel functions in numpy?", "question_body": "<pre><code>import numpy as np\ny = np.array(((1,2,3),(4,5,6),(7,8,9)))\nOUTPUT:\nprint(y.flatten())\n[1   2   3   4   5   6   7   8   9]\nprint(y.ravel())\n[1   2   3   4   5   6   7   8   9]\n</code></pre>\n\n<p>Both function return the same list.\nThen what is the need of two different functions performing same job.</p>\n", "link": "https://stackoverflow.com/questions/28930465/what-is-the-difference-between-flatten-and-ravel-functions-in-numpy", "question_id": 28930465, "accepted_answer_id": null}, {"title": "Numpy - array vs asarray", "question_body": "<p>What is the difference between Numpy's <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html#numpy.array\"><code>array()</code></a> and <a href=\"http://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray.html#numpy.asarray\"><code>asarray()</code></a> functions? When should you use one rather than the other? They seem to generate identical output for all the inputs I can think of.</p>\n", "link": "https://stackoverflow.com/questions/14415741/numpy-array-vs-asarray", "question_id": 14415741, "accepted_answer_id": 52103839, "answer_body": "<p>Since other questions are being redirected to this one which ask about <code>asanyarray</code> or <a href=\"https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html\" rel=\"noreferrer\">other array creation routines</a>, it's probably worth having a brief summary of what each of them does.</p>\n\n<p>The differences are mainly about when to return the input unchanged, as opposed to making a new array as a copy.</p>\n\n<p><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html\" rel=\"noreferrer\"><code>array</code></a> offers a wide variety of options (most of the other functions are thin wrappers around it), including flags to determine when to copy. A full explanation would take just as long as the docs (see <a href=\"https://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation\" rel=\"noreferrer\">Array Creation</a>, but briefly, here are some examples:</p>\n\n<p>Assume <code>a</code> is an <code>ndarray</code>, and <code>m</code> is a <code>matrix</code>, and they both have a <code>dtype</code> of <code>float32</code>:</p>\n\n<ul>\n<li><code>np.array(a)</code> and <code>np.array(m)</code> will copy both, because that's the default behavior.</li>\n<li><code>np.array(a, copy=False)</code> and <code>np.array(m, copy=False)</code> will copy <code>m</code> but not <code>a</code>, because <code>m</code> is not an <code>ndarray</code>.</li>\n<li><code>np.array(a, copy=False, subok=True)</code> and <code>np.array(m, copy=False, subok=True)</code> will copy neither, because <code>m</code> is a <code>matrix</code>, which is a subclass of <code>ndarray</code>.</li>\n<li><code>np.array(a, dtype=int, copy=False, subok=True)</code> will copy both, because the <code>dtype</code> is not compatible.</li>\n</ul>\n\n<p>Most of the other functions are thin wrappers around <code>array</code> that control when copying happens:</p>\n\n<ul>\n<li><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray.html\" rel=\"noreferrer\"><code>asarray</code></a>: The input will be returned uncopied iff it's a compatible <code>ndarray</code> (<code>copy=False</code>).</li>\n<li><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.asanyarray.html\" rel=\"noreferrer\"><code>asanyarray</code></a>: The input will be returned uncopied iff it's a compatible <code>ndarray</code> or subclass like <code>matrix</code> (<code>copy=False</code>, <code>subok=True</code>).</li>\n<li><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.ascontiguousarray.html\" rel=\"noreferrer\"><code>ascontiguousarray</code></a>: The input will be returned uncopied iff it's a compatible <code>ndarray</code> in contiguous C order (<code>copy=False</code>, <code>order='C')</code>.</li>\n<li><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.asfortranarray.html\" rel=\"noreferrer\"><code>asfortranarray</code></a>: The input will be returned uncopied iff it's a compatible <code>ndarray</code> in contiguous Fortran order (<code>copy=False</code>, <code>order='F'</code>).</li>\n<li><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.require.html\" rel=\"noreferrer\"><code>require</code></a>: The input will be returned uncopied iff it's compatible with the specified requirements string.</li>\n<li><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.copy.html\" rel=\"noreferrer\"><code>copy</code></a>: The input is always copied.</li>\n<li><a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html\" rel=\"noreferrer\"><code>fromiter</code></a>: The input is treated as an iterable (so, e.g., you can construct an array from an iterator's elements, instead of an <code>object</code> array with the iterator); always copied.</li>\n</ul>\n\n<p>There are also convenience functions, like <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray_chkfinite.html\" rel=\"noreferrer\"><code>asarray_chkfinite</code></a> (same copying rules as <code>asarray</code>, but raises <code>ValueError</code> if there are any <code>nan</code> or <code>inf</code> values), and constructors for subclasses like <code>matrix</code> or for special cases like record arrays, and of course the actual <a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html\" rel=\"noreferrer\"><code>ndarray</code></a> constructor (which lets you create an array directly out of strides over a buffer).</p>\n"}, {"title": "How do I check which version of NumPy I&#39;m using?", "question_body": "<p>How can I check which version of NumPy I'm using?</p>\n\n<p>(FYI this question has been edited because both the question and answer are not platform specific.)</p>\n", "link": "https://stackoverflow.com/questions/1520234/how-do-i-check-which-version-of-numpy-im-using", "question_id": 1520234, "accepted_answer_id": 1520275, "answer_body": "<pre><code>import numpy\nnumpy.version.version\n</code></pre>\n"}, {"title": "Most efficient way to reverse a numpy array", "question_body": "<p>Believe it or not, after profiling my current code, the repetitive operation of numpy array reversion ate a giant chunk of the running time. What I have right now is the common view-based method:</p>\n\n<pre><code>reversed_arr = arr[::-1]\n</code></pre>\n\n<p>Is there any other way to do it more efficiently, or is it just an illusion from my obsession with unrealistic numpy performance?</p>\n", "link": "https://stackoverflow.com/questions/6771428/most-efficient-way-to-reverse-a-numpy-array", "question_id": 6771428, "accepted_answer_id": 6771620, "answer_body": "<p>When you create <code>reversed_arr</code> you are creating a view into the original array.  You can then change the original array, and the view will update to reflect the changes.</p>\n\n<p>Are you re-creating the view more often than you need to?  You should be able to do something like this:</p>\n\n<pre><code>arr = np.array(some_sequence)\nreversed_arr = arr[::-1]\n\ndo_something(arr)\nlook_at(reversed_arr)\ndo_something_else(arr)\nlook_at(reversed_arr)\n</code></pre>\n\n<p>I'm not a numpy expert, but this seems like it would be the fastest way to do things in numpy.  If this is what you are already doing, I don't think you can improve on it.</p>\n\n<p>P.S. Great discussion of numpy views here:</p>\n\n<p><a href=\"https://stackoverflow.com/questions/4370745/view-onto-a-numpy-array\">View onto a numpy array?</a></p>\n"}]